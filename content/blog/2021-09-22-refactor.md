---
title: Easy Stuctural Refactors to Python Source Code
date: 2021-09-22
description: |
  Simple, hassle-free, dependency-free, AST based source code refactoring toolkit.

descriptionLong: |
  [Refactor](https://github.com/isidentical/refactor)  
  is a source code refactoring engine that takes the advantage of the AST module in the standard library. Through using it, we could find-and-fix patterns in massive codebases

picture: 2021-09-22/ast.png
author: batuhan_taskaya
commentsUrl: https://discuss.dvc.org/t/easy-structural-refactors-to-python-source-code/895
tags:
  - Refactor
  - AST
---

[Refactor](https://github.com/isidentical/refactor) is a source code refactoring
engine that takes the advantage of the AST module in the standard library.
Through using it, we could find-and-fix patterns in massive codebases

It is common for bigger codebases to grow to a complexity where it is really
hard for someone to go and refactor stuff manually on every occurence. There are
automated solutions for this, like regular expression based search and replace
tools, but the main problem with those are that they treat source code like a
regular text documents which might lead some issues like increased number of
some false positives (a case where the tool did change when it shouldn't) / true
negatives (a case where the tool didn't change when it should have), or even not
being able to truly express the structural concepts of the programming language
in them (since many of the programming have actual grammars which are impossible
to manifest in regexes). s This is where
[AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree)s shine, since they are
the common building blocks of the source code in the shape of the language's
syntax. They are produced as the result of an actual parser which understands
the language's syntax, and creates a tree object where smaller parts (e.g
tokens) are ordered in a way that they are related in terms of their syntactical
meanings.

```python
password = input("password? ")
if password == secrets.get("my_password"):
    print("correct")
else:
    print("incorrect")
```

For example, the AST for the code above will look like this:

![Fundamentals of MLOps](/uploads/images/2021-09-22/ast.png) _Abstract Syntax
Tree_

It is in the shape of a tree, where the root point represents a single Python
file. Each file consists from a number of statements (e.g function definitions,
loops), and for our example we have only 2 statements: an assignment (to
password), and an if statement. Each of these statements have their child
nodes/leaves, which are all defined in the
[Python's ASDL](https://docs.python.org/3/library/ast.html#abstract-grammar).

## Refactoring source code through ASTs

What [refactor](https://github.com/isidentical/refactor) does is that, it
enables the possibility of simply matching ASTs, and then transforming them to
different ones with doing as little as possible in terms of touching the other
parts of the source code.

```python
foo = [
    1,
    2
]

foo_2 = ['a', *foo]

if foo[0] >= 1:
    assert secrets.get("foo") == foo
```

As a simple demo, let's try to find and replace all usages of `foo` variable
name with `bar`, but without acrually changing stuff inside strings or partial
matches like `foo_2`.

```python
import ast
import refactor
```

The first thing we need to do is define a rule. Each rule is a class that
defines a single entrypoint (`match())`), takes AST nodes from the tree, and
either rejects them (via raising an `AssertionError` or just returning `None`)
or accepts them (via returning a `refactor.Action`).

```python
class ReplaceFoo(refactor.Rule):

    def match(self, node):
```

What we do in the `match()` method is simple, we will look for all `Name`s
(which is what the actual identifier is wrattped when used in the contexts
above), and check whetehr the `node.id` is `foo` or not.

```python
        assert isinstance(node, ast.Name)
        assert node.id == "foo"
```

If any of these assertions fail, the function will terminate at that point and
the engine will move to the next node in the tree. But if we succeed, then it
means that we have a match, and we should return some sort of an action. The
simplest thing we can use is just returning a `refactor.ReplacementAction` which
takes this node and replaces it with the given argument.

```python
        return refactor.ReplacementAction(
            node,
            ast.Name("bar", node.ctx)
        )
```

And this is it. If we want to try it, we can simply create a CLI application out
of our refactoring rules via `refactor.run()`.

```python
if __name__ == "__main__":
    refactor.run(rules=[ReplaceFoo])
```

And if we run it on the file above, we will get this diff:

```python
@@ -1,9 +1,9 @@

-foo = [
+bar = [
     1,
     2
 ]

-foo_2 = ['a', *foo]
+foo_2 = ['a', *bar]

-if foo[0] >= 1:
-    assert secrets.get("foo") == foo
+if bar[0] >= 1:
+    assert secrets.get("foo") == bar
```

Which indicates all of the usages against `foo` is replaced, but stuff like
`foo_2` or `"foo"` is still there as we have expected.

## Going Deeper

Obviously not all refactorings are as easy as this, so refactor is equipped with
more stuff like different action, and more advanced features like observers and
representatives for context manager. If you are curious about them, be sure to
check out it's [documentation!](https://refactor.readthedocs.io/en/latest/)

---

_Do you have any use case questions or need support? Join us in
[Discord](https://discord.com/invite/dvwXA2N)!_

_Head to the [DVC Forum](https://discuss.dvc.org/) to discuss your ideas and
best practices._
