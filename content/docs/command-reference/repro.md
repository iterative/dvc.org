# repro

Reproduce complete or partial [pipelines](/doc/command-reference/pipeline) by
executing commands defined in their [stages](/doc/command-reference/run) in the
correct order. The commands to be executed are determined by recursively
analyzing dependencies and <abbr>outputs</abbr> of the target stages.

## Synopsis

```usage
usage: dvc repro [-h] [-q | -v] [-f] [-s] [-c <path>] [-m] [--dry] [-i]
                 [-p] [-P] [-R] [--no-run-cache] [--force-downstream]
                 [--no-commit] [--downstream] [targets [targets ...]]

positional arguments:
  targets        Stage to reproduce.
```

## Description

`dvc repro` provides an way to regenerate data pipeline results, by restoring
the dependency graph (a
[DAG](https://en.wikipedia.org/wiki/Directed_acyclic_graph)) implicitly defined
by the [stage files](/doc/command-reference/run) (DVC-files with dependencies)
that are found in the <abbr>project</abbr>. The commands defined in these stages
can then be executed in the correct order, reproducing pipeline results.
`dvc repro` relies on the DAG definition that it reads from `dvc.yaml`, and uses
`dvc.lock` to determine what exactly needs to be run.

> Pipeline stages are typically defined using the `dvc run` command, while
> initial data dependencies can be registered by the `dvc add` command.

This command is similar to [Make](https://www.gnu.org/software/make/) in
software build automation, but DVC captures build requirements
([dependencies and outputs](/doc/command-reference/run#dependencies-and-outputs))
and caches relevant <abbr>data artifacts</abbr> along the way.

ðŸ’¡ For convenience, a Git hook is available to remind you to `dvc repro` when
needed after a `git commit`. See `dvc install` for more details.

There's a few ways to restrict the stages that will be regenerated by this
command: by specifying stage file `targets`, or by using the `--single-item`,
`--cwd`, or other options.

`dvc repro` does not run `dvc fetch`, `dvc pull` or `dvc checkout` to get data
files, intermediate or final results.

By default, this command recursively searches in pipeline stages, starting from
the `targets`, to determine which ones have changed. Then it executes the
corresponding commands. <abbr>Outputs</abbr> are deleted from the
<abbr>workspace</abbr> before executing the stages command that produces them.

> Note that stages without dependencies are considered _always changed_, so
> `dvc repro` always executes them.

It saves all the data files, intermediate or final results into the <abbr>DVC
cache</abbr> (unless the `--no-commit` option is used), and updates the hash
values of changed dependencies and outputs in the corresponding stage files.

### Parallel stage execution

Currently, `dvc repro` is not able to parallelize stage execution automatically.
If you need to do this, you can launch `dvc repro` multiple times manually. For
example, let's say a <abbr>pipeline</abbr> graph looks something like this:

```dvc
$ dvc dag
+--------+          +--------+
|   A1   |          |   B1   |
+--------+          +--------+
     *                   *
     *                   *
     *                   *
+--------+          +--------+
|   A2   |          |   B2   |
+--------+          +--------+
          *         *
           **     **
             *   *
        +------------+
        |    train   |
        +------------+
```

This pipeline consists of two parallel branches (`A` and `B`), and the final
"result" stage, where the branches merge. To reproduce both branches at the same
time, you could run `dvc repro A2` and `dvc repro B2` at the same time (e.g. in
separate terminals). After both finish successfully, you can then run
`dvc repro train`: DVC will know that both branches are already up-to-date and
only execute the final stage.

## Options

- `-f`, `--force` - reproduce a pipeline, regenerating its results, even if no
  changes were found. This executes all of the stages by default, but it can be
  limited with the `targets` argument, or the `-s`, `-p`, `-c` options.

- `-s`, `--single-item` - reproduce only a single stage by turning off the
  recursive search for changed dependencies. Multiple stages are executed
  (non-recursively) if multiple stage files are given as `targets`.

- `-c <path>`, `--cwd <path>` - directory within the project to reproduce from.
  Instead of using `--cwd`, one can alternately specify a target in a
  subdirectory as `path/to/target.dvc`. This option can be useful for example
  with subdirectories containing a separate pipeline that can either be
  reproduced as part of the pipeline in the parent directory, or as an
  independent unit.

- `-R`, `--recursive` - determines the stages to reproduce by searching each
  target directory and its subdirectories for DVC-files to inspect. If there are
  no directories among the `targets`, this option is ignored.

- `--no-commit` - do not save outputs to cache. A DVC-file is created and an
  entry is added to `.dvc/state`, while nothing is added to the cache.
  (`dvc status` will report that the file is `not in cache`.) Use `dvc commit`
  when ready to commit outputs with DVC. Useful to avoid caching unnecessary
  data repeatedly when running multiple experiments.

- `-m`, `--metrics` - show metrics after reproduction. The target pipelines must
  have at least one metric file defined either with the `dvc metrics` command,
  or by the `-M` or `-m` options of the `dvc run` command.

- `--dry` - only print the commands that would be executed without actually
  executing the commands.

- `-i`, `--interactive` - ask for confirmation before reproducing each stage.
  The stage is only executed if the user types "y".

- `-p`, `--pipeline` - reproduce the entire pipelines that the stage file
  `targets` belong to. Use `dvc dag <target>` to show the parent pipeline of a
  target stage.

- `-P`, `--all-pipelines` - reproduce all pipelines, for all the stage files
  present in `DVC` repository.

- `--no-run-cache` - execute stage commands even if they have already been run
  with the same command/dependencies/outputs/etc before.

- `--force-downstream` - in cases like `... -> A (changed) -> B -> C` it will
  reproduce `A` first and then `B`, even if `B` was previously executed with the
  same inputs from `A` (cached). To be precise, it reproduces all descendants of
  a changed stage or the stages following the changed stage, even if their
  direct dependencies did not change.

  It can be useful when we have a common dependency among all stages, and want
  to specify it only once (for stage `A` here). For example, if we know that all
  stages (`A` and below) depend on `requirements.txt`, we can specify it in `A`,
  and omit it in `B` and `C`.

  Like with the same option on `dvc run`, this is a way to force-execute stages
  without changes. This can also be useful for pipelines containing stages that
  produce non-deterministic (semi-random) outputs, where outputs can vary on
  each execution, meaning the cache cannot be trusted for such stages.

- `--downstream` - only execute the stages after the given `targets` in their
  corresponding pipelines, including the target stages themselves.

- `-h`, `--help` - prints the usage/help message, and exit.

- `-q`, `--quiet` - do not write anything to standard output. Exit with 0 if all
  stages are up to date or if all stages are successfully executed, otherwise
  exit with 1. The command defined in the stage is free to write output
  regardless of this flag.

- `-v`, `--verbose` - displays detailed tracing information.

## Examples

For simplicity, let's build a pipeline defined below. (If you want get your
hands-on something more real, see this short
[pipeline tutorial](/doc/tutorials/pipelines)). It takes this `text.txt` file:

```
dvc
1231
is
3
the
best
```

And runs a few simple transformations to filter and count numbers:

```dvc
$ dvc run -n filter -d text.txt -o numbers.txt \
           "cat text.txt | egrep '[0-9]+' > numbers.txt"

$ dvc run -n count -d numbers.txt -d process.py -M count.txt \
           "python process.py numbers.txt > count.txt"
```

> Note that a stage name is required when executing `dvc run`. It can be
> specified with `-n` (`--name`) option as we did above.

Where `process.py` is a script that, for simplicity, just prints the number of
lines:

```python
import sys
num_lines = 0
with open(sys.argv[1], 'r') as f:
    for line in f:
        num_lines += 1
print(num_lines)
```

The result of executing these `dvc run` commands should look like this:

```dvc
$ tree
.
â”œâ”€â”€ count.txt      <---- result: "2"
â”œâ”€â”€ dvc.lock       <---- file to record pipeline state
â”œâ”€â”€ dvc.yaml       <---- file containing list of stages.
â”œâ”€â”€ numbers.txt    <---- intermediate result of the first stage
â”œâ”€â”€ process.py     <---- code that implements data transformation
â””â”€â”€ text.txt       <---- text file to process
```

You may want to check the contents of `dvc.lock` and `count.txt` for later
reference.

Ok, now, let's run the `dvc repro` command:

```dvc
$ dvc repro
Stage 'filter' didn't change, skipping
Stage 'count' didn't change, skipping
Data and pipelines are up to date.
```

It makes sense, since we haven't changed neither of the dependencies this
pipeline has: `text.txt` or `process.py`. Now, let's imagine we want to print a
description and we add this line to the `process.py`:

```python
...
print('Number of lines:')
print(num_lines)
```

If we now run `dvc repro`, we should see this:

```dvc
$ dvc repro
Stage 'filter' didn't change, skipping
Running stage 'count' with command:
        python3 process.py numbers.txt > count.txt
Updating lock file 'dvc.lock'
```

You can now check that `dvc.lock` and `count.txt` have been updated with the new
information: updated dependency/output file hash values, and a new result,
respectively.

## Example: Downstream

The `--downstream` option allows us to only reproduce results from commands
after a specific stage in a pipeline. To demonstrate how it works, let's make a
change in `text.txt` (the input of our first stage, created in the previous
example):

```
...
The answer to universe is 42
- The Hitchhiker's Guide to the  Galaxy
```

Now, using the `--downstream` option results in the following output:

```dvc
$ dvc repro --downstream
Data and pipelines are up to date.
```

The reason being that the `text.txt` file is a dependency in the last stage of
the pipeline (used by default by `dvc repro`), This last `count` stage is
dependent on `filter` stage, which happens first in this pipeline (shown in the
following figure):

```dvc
$ dvc dag

    .------------.
    |   filter   |
    `------------'
           *
           *
           *
      .---------.
      |  count  |
      `---------'
```
